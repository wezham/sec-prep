# Binary Exploitation

## Calling conventions

### x86 architecture microprocessors

Calling conventions describe the interface of called code: 

* What order parameters are allocated
* How parameters are passed ( stack, registers or both )
* Which registers the function must preserve for the claler 
* The relationship of the caller/callee when preparing and restoring the stack

### x86 Registers

#### 32 bit

##### 8 General purpose registers: 

- Consider volatility ( do they change across functions )

|Register|Volatile|Uses|
|-----|-----|----|
|EAX|sort of |Store return value of a function, special register for certain calculations|
|EBX| no | nothing really but common used throughout function to speed up calcs | 
|ECX| yes | used as function param or loop counter ( fastcall) | 
|EDX| yes | used as function param ( fastcall ) or short term varialbles in functions |
|ESI| no| often used as a pointer ( 'rep' class instructions ) |
|EDI| no | often used as destination for data (rep class ) | 
|EBP| no | either frame pointer or general purpose register. Depends on compilation optimisation | 
|ESP| no, special | points to the top of the stack |

##### Special Purpose Registers:

|Register|Uses|
|-----|----|
|eip | instruction pointer. stores pointer to the currently executing instruction | 
|flags| contains information about whether something happened as a result of the last executed instruction | 



##### Understanding the Stack

Recall the stack grows downwards

```
--- 0xFFFFFFFF <= ESP 

--- 0xFFFFFFFE

--- 0xFFFFFFFD

--- 0x000000000
``` 


* The `push` instruction places its operand onto the top of the hardware supported stack in memory. Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address
* The `pop` instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments SP by 4.


```
--- 0xFFFFFFFF <= ESP 

--- 0xFFFFFFFE

--- 0xFFFFFFFD

--- 0x000000000
``` 

> push 0x11111111

```
--- 0xFFFFFFFF  

--- 0xFFFFFFFE <= ESP = ESP - 4 bytes, *ESP = 0x11111111

--- 0xFFFFFFFD

--- 0x000000000
``` 

> pop eax

```
--- 0xFFFFFFFF <= ESP = ESP + 4 bytes

--- 0xFFFFFFFE - EAX = 0x11111111

--- 0xFFFFFFFD

--- 0x000000000
```

It might be easier to visualise the stack as growing from bottom to top
but don't make this misconception a reality:

```
--- 0xffffffcf

--- 0xffffffdf

--- 0xffffffef

--- 0xffffffff <= ESP 
``` 

> push 0x11111111

```
--- 0xffffffcf

--- 0xffffffdf

--- 0xffffffef <= ESP , *ESP = 0x11

--- 0xffffffff  
```  

> pop eax

```
--- 0xffffffcf

--- 0xffffffdf

--- 0xffffffef

--- 0xffffffff <= ESP , EAX = 0x11
``` 

_CDECL_

* Arguments are passed on the stack 
* Integer values and memory addresses are returned in the EAX register
* Floating point values in the STO register
* Registers EAX, ECX, EDX are saved by the caller 
* C arguments, the last parameter is pushed first 
* Callee creates and cleans up the stack


Lets imagine our x86 code when we called this method: 

```c
int add(int a, int b)
{
    return ( a + b ) + 5;
}


int main(int argc, char *argv[])
{
    add(1, 2);
}

```

Lets talk about passing by reference vs actual values:

This is passing by value:
```
push 2 # Arguments are pushed from right to left
push 1
call add 
```

This is passing by value:
```
mov [ebp - 0x44], 2
mov [ebp - 0x48], 1
lea eax, [ebp - 0x44]
push eax
lea eax, [ebp - 0x48]
push eax # Arguments are pushed from right to left
push 1
call add 
sub esp, 8
```

Lets now imagine for a moment what happens at the time we call `call add`.

Stack before the call:

```
1 <= ESP
2 
0xbeefbeef 
```

Stack after the call:

```
* EIP + size_of_last_instruction <= ESP
1
2 
0xbeefbeef 
```

caller:

```
push ebp <= store the stack frame base of the caller
move ebp, esp <= store the base of the current stack frame
.... # do stuff
```

Stack after this:

`EBP = pointer to EBP of caller`
```
EBP of caller <= ESP
* EIP + size_of_last_instruction ( Return address )
1
2 
0xbeefbeef 
```

Then the caller does its stuff and finishes with: 

```
leave <= set ESP = what EBP pointers to, pop EBP, EBP becomes equal to prior frame
```

Stack becomes:
```
* EIP + size_of_last_instruction ( Return address ) <= ESP
1
2 
0xbeefbeef
```

And finally:
```
ret # Jump to the address at the top of the stack
```

Then in the caller:

```
call add
sub esp 8
...
```

Understanding the above flow is crucial to understanding buffer overflows.

