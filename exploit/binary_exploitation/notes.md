# Binary Exploitation

## Calling conventions

### x86 architecture microprocessors

Calling conventions describe the interface of called code: 

* What order parameters are allocated
* How parameters are passed ( stack, registers or both )
* Which registers the function must preserve for the claler 
* The relationship of the caller/callee when preparing and restoring the stack

### x86 Registers

#### 32 bit

##### 8 General purpose registers: 

- Consider volatility ( do they change across functions )

|Register|Volatile|Uses|
|-----|-----|----|
|EAX|sort of |Store return value of a function, special register for certain calculations|
|EBX| no | nothing really but common used throughout function to speed up calcs | 
|ECX| yes | used as function param or loop counter ( fastcall) | 
|EDX| yes | used as function param ( fastcall ) or short term varialbles in functions |
|ESI| no| often used as a pointer ( 'rep' class instructions ) |
|EDI| no | often used as destination for data (rep class ) | 
|EBP| no | either frame pointer or general purpose register. Depends on compilation optimisation | 
|ESP| no, special | points to the top of the stack |

##### Special Purpose Registers:

|Register|Uses|
|-----|----|
|eip | instruction pointer. stores pointer to the currently executing instruction | 
|flags| contains information about whether something happened as a result of the last executed instruction | 



##### Understanding the Stack

Recall the stack grows downwards

```
--- 0xFFFFFFFF <= ESP 

--- 0xFFFFFFFE

--- 0xFFFFFFFD

--- 0x000000000
``` 


* The `push` instruction places its operand onto the top of the hardware supported stack in memory. Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address
* The `pop` instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments SP by 4.


```
--- 0xFFFFFFFF <= ESP 

--- 0xFFFFFFFE

--- 0xFFFFFFFD

--- 0x000000000
``` 

> push 0x11111111

```
--- 0xFFFFFFFF  

--- 0xFFFFFFFE <= ESP = ESP - 4 bytes, *ESP = 0x11111111

--- 0xFFFFFFFD

--- 0x000000000
``` 

> pop eax

```
--- 0xFFFFFFFF <= ESP = ESP + 4 bytes

--- 0xFFFFFFFE - EAX = 0x11111111

--- 0xFFFFFFFD

--- 0x000000000
```



_CDECL_

* Arguments are passed on the stack 
* Integer values and memory addresses are returned in the EAX register
* Floating point values in the STO register
* Registers EAX, ECX, EDX are saved by the caller 
* C arguments, the last parameter is pushed first 
* Callee creates and cleans up the stack

Take the following 32 bit assembly code:

```
0x80485b1 <main+35>    push   0
0x80485b3 <main+37>    push   eax
0x80485b4 <main+38>    call   setbuf@plt                     <setbuf@plt>
0x80485b9 <main+43>    add    esp, 8
``` 

We can see the following
```
> man setbuf
     void
     setbuf(FILE *restrict stream, char *restrict buf);
```

```
push 0 <= put the pointer buf onto the stack 
push eax <= put the file pointer onto the stack 
call the method
move the stackpointer 8 bytes up ( cleanup the stack ) 
```